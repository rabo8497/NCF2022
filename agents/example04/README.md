# 네 번째 예제

이전 예제의 문제점은 한 번 방문한 곳도 다시 방문할 수 있다는 점이다. 단적인 예시로 아래 상황을 보자.
```
 -
|.|
|.|
|@|
```
첫 번째 상황이다. 우선 북쪽이 이동 가능하므로 북쪽으로 한 번 이동한다.
```
 -
|.|
|@|
|.|
```
두 번째 상황이다. 다시 한 번 북쪽이 이동 가능하므로 북쪽으로 한 번 이동한다.
```
 -
|@|
|.|
|.|
```
세 번째 상황이다. 북쪽이 이동할 수 없으므로 동쪽을 확인한다. 동쪽 또한 이동할 수 없으므로 남쪽을 확인한다. 남쪽이 이동 가능하므로 남쪽으로 한 번 이동한다.
```
 -
|.|
|@|
|.|
```
네 번째 상황이다. 두 번째 상황과 완전히 동일한 상황이다. 기존 예제의 코드에서는 이 경우 두 번째 상황과 동일하게 북쪽을 선택할 것이고, 같은 상황이 계속해서 반복되는 문제를 야기한다.

그렇다면 이러한 문제를 해결하기 위해 어떤 방법을 적용할 수 있을까? 우선 처음으로 떠오르는 방법은 맵에서 방문한 곳과 방문하지 않은 곳을 저장하여 방문하지 않은 곳만 탐색하도록 할 수 있다. 하지만 때때로 방문했던 곳도 다시 방문해야 하는 경우가 생긴다. 위 예시의 세 번째 상황에서 북, 동, 서쪽은 이동할 수 없기 때문에, 이미 한 번 방문한 곳이지만 남쪽을 선택할 수 밖에 없다. 이런 상황을 해결하기 위해 이번 예제에서는 탐색 방법 중 하나인 DFS를 적용한다. BFS를 사용하지 않는 이유는 미로를 직접 탐험하며 맵에 대한 정보를 얻어오는 넷핵의 특성상 BFS 방법은 적용시키기 어렵기 때문이다. 이번 예제에서는 각 노드의 부모 노드와 자식 노드를 기억하도록 하여 DFS를 구현하였다. 또한 내려가는 계단을 발견하면 곧바로 내려가도록 하고, 더 이상 탐색할 곳이 없을 때는 원점으로 돌아왔다고 판단하여 계단을 올라가도록 하였다.

```agent.py```의 ```__init__``` 함수와 ```new_lv``` 함수, ```get_action``` 함수, ```preprocess_map``` 함수를 참고하자. ```__init__``` 함수에서는 우선 구현에 필요한 클래스 변수를 선언한다. DFS에서 각 좌표 노드의 부모와 자식 노드를 기억하도록 하는 ```parent```, ```children``` 리스트와 방문 여부를 저장하는 ```visited``` 리스트를 선언한다. 그리고 이번 층의 내려가는 계단의 좌표를 저장하기 위한 ```goal```, 던전 레벨을 저장하는 ```dungeon_lv``` 변수를 선언하였다. 또한 이번 예제에서는 이동의 방향을 북, 동, 남, 서로 제한하였지만, 필요에 따라 코드를 수정하여 8방향으로 이동 가능하게 수정할 수 있다. 그리고 필요시 이들을 초기화할 수 있는 ```new_lv``` 함수도 선언하였다. 전처리 과정은 이전 예제와 동일하며, 내려가는 계단을 발견했을 때 해당 위치를 ```goal```에 저장하는 코드만 추가한다. ```get_action``` 함수에서는 DFS 구현이 추가되었다. 계단을 내려가거나 함정을 밟아 다른 단계로 갔을 때 새로운 단계가 시작되므로 ```new_lv``` 함수를 실행한다. 이후 현재 위치에서 이동 가능한 방향을 찾고 방향 정보를 자식 리스트에 추가하며, 각 자식 노드에는 부모 노드의 방향 정보를 저장하도록 한다.

이외에도 더 이상 탐색할 곳이 없을 때 벽에 붙어 수색하기 action을 시도하도록 하는 규칙, 음식이 있을 때 음식을 먹도록 하는 규칙 등 예제에서 직접적으로 다루지 않은 넷핵의 플레이 규칙도 존재한다. 이들에 대한 규칙도 직접 구현하여 해결하면 더욱 원활하게 진행될 수 있다. 원활한 시뮬레이션을 위해 이번 예제에서 소개한 규칙과 별개로 게임이 더 이상 진행되지 않는다고 판단했을 때 임의의 action을 반환하는 규칙을 추가하였다. 이는 ```get_action``` 함수에 구현되어 있다(line 35~46).

이 예제를 실행하려면 다음 명령어를 터미널에서 입력하도록 하자.

```
(nle) ~/NCF2022$ python run.py --run agents.example04
```

